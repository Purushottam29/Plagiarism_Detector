{
  "file_id": "8ef907bfec594ccbba7fa38e56c3dfa2",
  "sentences": [
    "Flutter Assignment-2\nName :- Purushottam Choudhary\nSystem id:- 2022592906\nSection - A\nSections - A\nQ1) Write a Flutter app to toggle between dark and light themes using Provider.",
    "Ans:- Code to toggle between light and dark theme using provide is below:-\n\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeProvider(),\n      child: const MyApp(),\n    ),\n  );\n}\nclass ThemeProvider extends ChangeNotifier {\n  bool isDark = false;\n  void toggleTheme() {\n    isDark = !isDark;\n    notifyListeners();\n  }\n}\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<ThemeProvider>(\n      builder: (context, provider, _) {\n        return MaterialApp(\n          theme: provider.isDark ?",
    "ThemeData.dark() : ThemeData.light(),\n          home: const HomePage(),\n        );\n      },\n    );\n  }\n}\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Theme Toggle\")),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () => context.read<ThemeProvider>().toggleTheme(),\n          child: const Text(\"Toggle Theme\"),\n        ),\n      ),\n    );\n  }\n}\nQ2) Demonstrate the use of Consumer widget in Provider state management.",
    "Ans:- The Consumer widget listens to Provider's changes and rebuilds only the wrapped UI portion.",
    "This ensures maximum performance and avoids rebuilding unnecessary widgets.",
    "Below is the code to demonstrate:-\n\nclass CounterProvider extends ChangeNotifier {\n  int count = 0;\n  void increment() {\n    count++;\n    notifyListeners();\n  }\n}\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Consumer Example\")),\n      body: Center(\n        child: Consumer<CounterProvider>(\n          builder: (context, provider, child) {\n            return Text(\n              \"Count: ${provider.count}\",\n              style: const TextStyle(fontSize: 30),\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterProvider>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\nQ3) Implement an edit feature for records stored in SQLite.",
    "Ans:- Below is the code :-\nclass DBHelper {\n  Future<Database> initDB() async {\n    return openDatabase(\n      \"students.db\",\n      version: 1,\n      onCreate: (db, version) {\n        db.execute(\n            \"CREATE TABLE student(id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\");\n      },\n    );\n  }\n  Future<int> updateStudent(int id, String name, int age) async {\n    final db = await initDB();\n    return db.update(\n      \"student\",\n      {\"name\": name, \"age\": age},\n      where: \"id = ?\",\n      whereArgs: [id],\n    );\n  }\n}\nCode for edit screen is below:-\nclass EditStudent extends StatefulWidget {\n  final Map data;\n  EditStudent(this.data);\n  @override\n  _EditStudentState createState() => _EditStudentState();\n}\nclass _EditStudentState extends State<EditStudent> {\n  late TextEditingController nameC;\n  late TextEditingController ageC;\n  @override\n  void initState() {\n    nameC = TextEditingController(text: widget.data[\"name\"]);\n    ageC = TextEditingController(text: widget.data[\"age\"].toString());\n    super.initState();\n  }\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Edit Record\")),\n      body: Column(\n        children: [\n          TextField(controller: nameC),\n          TextField(controller: ageC),\n          ElevatedButton(\n            onPressed: () {\n              DBHelper().updateStudent(\n                widget.data[\"id\"],\n                nameC.text,\n                int.parse(ageC.text),\n              );\n            },\n            child: const Text(\"Update\"),\n          )\n        ],\n      ),\n    );\n  }\n}\nQ4) Store form data in a local JSON file using path provider.",
    "Ans:- Saving data to JSON locally allows offline access without a database.",
    "Steps\nUse path_provider to get the documents directory.",
    "Create a JSON file if not exists.",
    "Convert form data to Map \u2192 JSON string using jsonEncode.",
    "Write to file with File.writeAsString.",
    "Code:-\nimport 'dart:convert';\nimport 'dart:io';\nimport 'package:path_provider/path_provider.dart';\nFuture<void> saveFormData(String name, String email) async {\n  final directory = await getApplicationDocumentsDirectory();\n  final file = File(\"${directory.path}/formData.json\");\n  Map<String, dynamic> data = {\n    \"name\": name,\n    \"email\": email,\n  };\n  await file.writeAsString(jsonEncode(data));\n}\nSection- B\nQ5) Use ImagePicker and upload selected image to Firebase Storage.",
    "Ans:- Code to demonstrate:-\nimport 'dart:io';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:firebase_storage/firebase_storage.dart';\nFuture<void> pickAndUpload() async {\n  final picker = ImagePicker();\n  final picked = await picker.pickImage(source: ImageSource.gallery);\n  if (picked != null) {\n    File file = File(picked.path);\n    String fileName = DateTime.now().millisecondsSinceEpoch.toString();\n    await FirebaseStorage.instance\n        .ref(\"uploads/$fileName.jpg\")\n        .putFile(file);\n    print(\"Uploaded Successfully\");\n  }\n}\nQ6) Build and deploy email and password sign-up window using Firebase Authentication.",
    "Ans:- Steps\nAdd Firebase to project.",
    "Enable Email/Password in Firebase Authentication console.",
    "Use FirebaseAuth.instance.createUserWithEmailAndPassword.",
    "Code:-\nimport 'package:flutter/material.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nclass SignUpPage extends StatefulWidget {\n  @override\n  _SignUpPageState createState() => _SignUpPageState();\n}\nclass _SignUpPageState extends State<SignUpPage> {\n  final emailC = TextEditingController();\n  final passC = TextEditingController();\n  Future<void> signUp() async {\n    await FirebaseAuth.instance.createUserWithEmailAndPassword(\n      email: emailC.text,\n      password: passC.text,\n    );\n    ScaffoldMessenger.of(context)\n        .showSnackBar(const SnackBar(content: Text(\"User Registered\")));\n  }\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Firebase Sign Up\")),\n      body: Column(\n        children: [\n          TextField(controller: emailC),\n          TextField(controller: passC, obscureText: true),\n          ElevatedButton(onPressed: signUp, child: const Text(\"Sign Up\")),\n        ],\n      ),\n    );\n  }\n}"
  ],
  "corpus_texts": [
    "Tesseract OCR The main task was t0 recognize receipts from photos Tesseract OCR was used as a primary tool. Library pros are trainedlanguage models (>192), different kinds of recognition (image as word, text block; vertical text), easy to setup: 3rd party wrapper from github was used as Tesseract OCR was written on C++. The version difference is in different trained models (the 4th version is more accurate S0 [ used it). We need file with data for text recognition, for each language each file: Download here: The better the image quality (size, contrast, lightning) the better the recognition result: Also the image processing was found for the further recognition by the OpenCV library As OpenCV is written on C++ and there $ no optimalwrapper for our decision s0 [ made my own wrapper for this library with necessary functions for image processing: The main",
    "Flutter Assignment-2\nName :- Purushottam Choudhary\nSystem id:- 2022592906\nSection - A\nSections - A\nQ1) Write a Flutter app to toggle between dark and light themes using Provider.\nAns:- Code to toggle between light and dark theme using provide is below:-\n\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => ThemeProvider(),\n      child: const MyApp(),\n    ),\n  );\n}\n\nclass ThemeProvider extends ChangeNotifier {\n  bool isDark = false;\n\n  void toggleTheme() {\n    isDark = !isDark;\n    notifyListeners();\n  }\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<ThemeProvider>(\n      builder: (context, provider, _) {\n        return MaterialApp(\n          theme: provider.isDark ? ThemeData.dark() : ThemeData.light(),\n          home: const HomePage(),\n        );\n      },\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Theme Toggle\")),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () => context.read<ThemeProvider>().toggleTheme(),\n          child: const Text(\"Toggle Theme\"),\n        ),\n      ),\n    );\n  }\n}\n\nQ2) Demonstrate the use of Consumer widget in Provider state management.\nAns:- The Consumer widget listens to Provider's changes and rebuilds only the wrapped UI portion. This ensures maximum performance and avoids rebuilding unnecessary widgets.\nBelow is the code to demonstrate:-\n\nclass CounterProvider extends ChangeNotifier {\n  int count = 0;\n  void increment() {\n    count++;\n    notifyListeners();\n  }\n}\n\nclass CounterScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Consumer Example\")),\n      body: Center(\n        child: Consumer<CounterProvider>(\n          builder: (context, provider, child) {\n            return Text(\n              \"Count: ${provider.count}\",\n              style: const TextStyle(fontSize: 30),\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => context.read<CounterProvider>().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\nQ3) Implement an edit feature for records stored in SQLite.\nAns:- Below is the code :-\nclass DBHelper {\n  Future<Database> initDB() async {\n    return openDatabase(\n      \"students.db\",\n      version: 1,\n      onCreate: (db, version) {\n        db.execute(\n            \"CREATE TABLE student(id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\");\n      },\n    );\n  }\n\n  Future<int> updateStudent(int id, String name, int age) async {\n    final db = await initDB();\n    return db.update(\n      \"student\",\n      {\"name\": name, \"age\": age},\n      where: \"id = ?\",\n      whereArgs: [id],\n    );\n  }\n}\n\nCode for edit screen is below:-\nclass EditStudent extends StatefulWidget {\n  final Map data;\n  EditStudent(this.data);\n\n  @override\n  _EditStudentState createState() => _EditStudentState();\n}\n\nclass _EditStudentState extends State<EditStudent> {\n  late TextEditingController nameC;\n  late TextEditingController ageC;\n\n  @override\n  void initState() {\n    nameC = TextEditingController(text: widget.data[\"name\"]);\n    ageC = TextEditingController(text: widget.data[\"age\"].toString());\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Edit Record\")),\n      body: Column(\n        children: [\n          TextField(controller: nameC),\n          TextField(controller: ageC),\n          ElevatedButton(\n            onPressed: () {\n              DBHelper().updateStudent(\n                widget.data[\"id\"],\n                nameC.text,\n                int.parse(ageC.text),\n              );\n            },\n            child: const Text(\"Update\"),\n          )\n        ],\n      ),\n    );\n  }\n}\n\nQ4) Store form data in a local JSON file using path provider.\nAns:- Saving data to JSON locally allows offline access without a database.\nSteps\n    1. Use path_provider to get the documents directory.\n    2. Create a JSON file if not exists.\n    3. Convert form data to Map \u2192 JSON string using jsonEncode.\n    4. Write to file with File.writeAsString.\nCode:-\nimport 'dart:convert';\nimport 'dart:io';\nimport 'package:path_provider/path_provider.dart';\n\nFuture<void> saveFormData(String name, String email) async {\n  final directory = await getApplicationDocumentsDirectory();\n  final file = File(\"${directory.path}/formData.json\");\n\n  Map<String, dynamic> data = {\n    \"name\": name,\n    \"email\": email,\n  };\n\n  await file.writeAsString(jsonEncode(data));\n}\n\nSection- B\nQ5) Use ImagePicker and upload selected image to Firebase Storage.\nAns:- Code to demonstrate:-\nimport 'dart:io';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:firebase_storage/firebase_storage.dart';\n\nFuture<void> pickAndUpload() async {\n  final picker = ImagePicker();\n  final picked = await picker.pickImage(source: ImageSource.gallery);\n\n  if (picked != null) {\n    File file = File(picked.path);\n    String fileName = DateTime.now().millisecondsSinceEpoch.toString();\n\n    await FirebaseStorage.instance\n        .ref(\"uploads/$fileName.jpg\")\n        .putFile(file);\n\n    print(\"Uploaded Successfully\");\n  }\n}\n\nQ6) Build and deploy email and password sign-up window using Firebase Authentication.\nAns:- Steps\n    1. Add Firebase to project.\n    2. Enable Email/Password in Firebase Authentication console.\n    3. Use FirebaseAuth.instance.createUserWithEmailAndPassword.\nCode:-\nimport 'package:flutter/material.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\n\nclass SignUpPage extends StatefulWidget {\n  @override\n  _SignUpPageState createState() => _SignUpPageState();\n}\n\nclass _SignUpPageState extends State<SignUpPage> {\n  final emailC = TextEditingController();\n  final passC = TextEditingController();\n\n  Future<void> signUp() async {\n    await FirebaseAuth.instance.createUserWithEmailAndPassword(\n      email: emailC.text,\n      password: passC.text,\n    );\n    ScaffoldMessenger.of(context)\n        .showSnackBar(const SnackBar(content: Text(\"User Registered\")));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text(\"Firebase Sign Up\")),\n      body: Column(\n        children: [\n          TextField(controller: emailC),\n          TextField(controller: passC, obscureText: true),\n          ElevatedButton(onPressed: signUp, child: const Text(\"Sign Up\")),\n        ],\n      ),\n    );\n  }\n}\n",
    "Tesseract OCR The main task was t0 recognize receipts from photos Tesseract OCR was used as a primary tool.\nLibrary pros are trainedlanguage models (>192), different kinds of recognition (image as word, text block; vertical text), easy to setup: 3rd party wrapper from github was used as Tesseract OCR was written on C++.\nThe version difference is in different trained models (the 4th version is more accurate S0 [ used it).\nWe need file with data for text recognition, for each language each file: Download here: The better the image quality (size, contrast, lightning) the better the recognition result: Also the image processing was found for the further recognition by the OpenCV library As OpenCV is written on C++ and there $ no optimalwrapper for our decision s0 [ made my own wrapper for this library with necessary functions for image processing: The main\n"
  ]
}